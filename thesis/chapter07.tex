%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Discussion and conclusion}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theoretically all methods perform about the same when $p$ is separable. If $p$ is not separable DM has a clear advantage. If we assume $\gamma \propto m^2/n^2$, which we concluded in section \ref{sec:rrest}, and use $n = \rho$ as suggested in section \ref{sec:restvar}, we get that KPM$(\rho)$ performs asymptotically equal to KPM. This follows from table \ref{tab:cc}. \\

%that KPM$(\rho)$ has the same complexity as KPM. So if $p$ is separable all methods perform equally well, if $p$ is non-separable DM requires fewer operations. 

 %if $p$ is separable. If $p$ is not separable DM has again an advantage over KPM and KPM$(n)$. \\

Table \ref{tab:mr} shows that KPM$(\rho)$ uses the least amount of memory. This is one of the main reasons to use KPM instead of DM on this type of problems. \\

Regarding convergence all methods can perform equally well, the drawback is the need to choose an appropriate $\delta$ for KPM$(n)$. With a larger $\delta$ KPM$(n)$ is less accurate, but with smaller $\delta$ we restart too many times, making the methods inefficient. The rule of thumbs is start at $\delta=10^{-3}$ with $\rho = k = n = 10$, and decrease $\delta$ with two orders of magnitude each time $\rho = k = n$ is doubled. \\

When $p$ is separable, the results from section \ref{sec:stimem} and \ref{sec:stimek} shows that KPM$(n)$ is faster and asymptotically better than DM. This contradicts the results from theoretical complexity, and might be due to the smaller memory demand. \\

The reason for the high parallel performance in section \ref{sec:speed} is the natural independence in the method. The only communication needed between processors is when adding results, this can be done in $\log_2(\texttt{nP})$ additions. Note that a good restart variable is also gives a good problem size to use with parallel computations. \\

In section \ref{sec:compare} we used what we had learned about $\gamma$, $n$ and $\delta$ to make KPM$(n)$ run as fast as possible with $p$ non-separable. DM was faster than KPM$(\rho)$, but not asymptotically, as suggested by table \ref{tab:cc}. With more processors KPM$(n)$ would have been faster because of the high parallel efficiency and the low cost of solving each of the $m$ independent problems.

It is worth noting that DM did not work when $\rho>300$ due to memory shortage, while KPM$(n)$ had no problem with $\rho = 1000$ and $n = 40$. \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Further work}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
To obtain better results KPM should be implemented in a more parallel friendly language, as for example \texttt{C}. It would also be a benefit to use a large computer, making it easier to get data with larger $\rho$ and $k$.

It would also be interesting to see how KPM could be used to solve other equations than the heat equation.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{My code}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

If you are interested in any of the code used here you can find it at: \\
\emph{https://github.com/sindreka/Prosjektoppgave}
